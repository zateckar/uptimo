// Edit Monitor Page JavaScript
document.addEventListener('DOMContentLoaded', function() {
    const monitorType = document.getElementById('monitor_type');
    const targetField = document.getElementById('target_field');
    const targetHelp = document.getElementById('target_help');
    const portFieldGroup = document.getElementById('port_field_group');
    const httpSettings = document.getElementById('http_settings');
    const toggleAdvanced = document.getElementById('toggle_advanced');
    const advancedSettings = document.getElementById('advanced_settings');
    const toggleNotifications = document.getElementById('toggle_notifications');
    const notificationSettings = document.getElementById('notification_settings');
    
    // Kafka field elements (declare early for use in functions)
    const kafkaSecurityProtocol = document.getElementById('kafka_security_protocol');
    const kafkaSaslMechanism = document.getElementById('kafka_sasl_mechanism');
    const kafkaWriteMessage = document.getElementById('kafka_write_message');
    
    // HTTP elements
    const httpMethod = document.getElementById('http_method');
    const httpBodyGroup = document.getElementById('http_body_group');
    
    // Domain check elements
    const checkDomainCheckbox = document.getElementById('check_domain');
    const expectedDomainField = document.getElementById('expected_domain');
    
    // Kafka settings dynamic field visibility function
    function updateKafkaFields() {
        const protocol = kafkaSecurityProtocol ? kafkaSecurityProtocol.value : '';
        const mechanism = kafkaSaslMechanism ? kafkaSaslMechanism.value : '';
        const writeMsg = kafkaWriteMessage ? kafkaWriteMessage.checked : false;
        
        // SASL mechanism field visibility
        const saslMechanismGroup = document.getElementById('kafka_sasl_mechanism_group');
        if (saslMechanismGroup) {
            if (protocol === 'SASL_SSL' || protocol === 'SASL_PLAINTEXT') {
                saslMechanismGroup.classList.remove('d-none');
            } else {
                saslMechanismGroup.classList.add('d-none');
            }
        }
        
        // SASL username/password visibility
        const saslUsernameGroup = document.getElementById('kafka_sasl_username_group');
        const saslPasswordGroup = document.getElementById('kafka_sasl_password_group');
        const showSaslCreds = ['PLAIN', 'SCRAM-SHA-256', 'SCRAM-SHA-512'].includes(mechanism);
        if (saslUsernameGroup) {
            if (showSaslCreds) {
                saslUsernameGroup.classList.remove('d-none');
            } else {
                saslUsernameGroup.classList.add('d-none');
            }
        }
        if (saslPasswordGroup) {
            if (showSaslCreds) {
                saslPasswordGroup.classList.remove('d-none');
            } else {
                saslPasswordGroup.classList.add('d-none');
            }
        }
        
        // OAuth fields visibility
        const oauthGroup = document.getElementById('kafka_oauth_group');
        if (oauthGroup) {
            if (mechanism === 'OAUTHBEARER') {
                oauthGroup.classList.remove('d-none');
            } else {
                oauthGroup.classList.add('d-none');
            }
        }
        
        // SSL group visibility (show for SSL and SASL_SSL)
        const sslGroup = document.getElementById('kafka_ssl_group');
        if (sslGroup) {
            if (protocol === 'SSL' || protocol === 'SASL_SSL') {
                sslGroup.classList.remove('d-none');
            } else {
                sslGroup.classList.add('d-none');
            }
        }
        
        // Message payload visibility
        const payloadGroup = document.getElementById('kafka_message_payload_group');
        if (payloadGroup) {
            if (writeMsg) {
                payloadGroup.classList.remove('d-none');
            } else {
                payloadGroup.classList.add('d-none');
            }
        }
    }
    
    // HTTP method body visibility function
    function updateHttpBodyVisibility() {
        if (httpMethod && httpBodyGroup) {
            const method = httpMethod.value;
            const showBody = ['POST', 'PUT', 'PATCH'].includes(method);
            if (showBody) {
                httpBodyGroup.classList.remove('d-none');
            } else {
                httpBodyGroup.classList.add('d-none');
            }
        }
    }
    
    // Helper function to extract domain from URL or Kafka broker address
    function extractDomainFromUrl(url) {
        try {
            const urlObj = new URL(url);
            return urlObj.hostname;
        } catch (e) {
            // For Kafka broker addresses (host:port format)
            if (url && url.includes(':')) {
                const parts = url.split(':');
                return parts[0];
            }
            // For plain hostnames
            return url || '';
        }
    }
    
    // Monitor type specific field visibility
    function updateFieldsForType(type) {
        // Reset all fields
        portFieldGroup.classList.add('d-none');
        httpSettings.classList.add('d-none');
        const kafkaSettings = document.getElementById('kafka_settings');
        if (kafkaSettings) kafkaSettings.classList.add('d-none');
        
        // Update target help text and validation
        switch(type) {
            case 'http':
            case 'https':
                targetHelp.textContent = `Enter a full ${type.toUpperCase()} URL (e.g., https://example.com/api/health)`;
                httpSettings.classList.remove('d-none');
                break;
            case 'tcp':
                targetHelp.textContent = 'Enter hostname or IP address for TCP connection';
                portFieldGroup.classList.remove('d-none');
                break;
            case 'ping':
                targetHelp.textContent = 'Enter hostname or IP address to ping';
                break;
            case 'kafka':
                targetHelp.textContent = 'Enter Kafka broker address (e.g., kafka.example.com:9092)';
                if (kafkaSettings) {
                    kafkaSettings.classList.remove('d-none');
                    updateKafkaFields(); // Ensure fields are properly set up when showing Kafka settings
                }
                break;
            default:
                targetHelp.textContent = 'Enter the target to monitor';
        }
    }
    
    // Initial field setup
    updateFieldsForType(monitorType.value);
    
    // Handle monitor type change
    monitorType.addEventListener('change', function() {
        updateFieldsForType(this.value);
    });
    
    // Toggle advanced settings
    toggleAdvanced.addEventListener('click', function() {
        const isHidden = !advancedSettings.classList.contains('show');
        const button = this.querySelector('button');
        
        if (isHidden) {
            advancedSettings.classList.add('show');
            button.innerHTML = '<span class="me-1">Hide</span> <i class="bi bi-chevron-up"></i>';
        } else {
            advancedSettings.classList.remove('show');
            button.innerHTML = '<span class="me-1">Show</span> <i class="bi bi-chevron-down"></i>';
        }
    });
    
    // Toggle notification settings (only on edit page)
    if (toggleNotifications && notificationSettings) {
        toggleNotifications.addEventListener('click', function() {
            const isHidden = !notificationSettings.classList.contains('show');
            const button = this.querySelector('button');
            
            if (isHidden) {
                notificationSettings.classList.add('show');
                button.innerHTML = '<span class="me-1">Hide</span> <i class="bi bi-chevron-up"></i>';
            } else {
                notificationSettings.classList.remove('show');
                button.innerHTML = '<span class="me-1">Show</span> <i class="bi bi-chevron-down"></i>';
            }
        });
    }
    
    // Form validation
    const form = document.querySelector('.needs-validation');
    if (form) {
        form.addEventListener('submit', function(event) {
            if (!form.checkValidity()) {
                event.preventDefault();
                event.stopPropagation();
            }
            form.classList.add('was-validated');
        }, false);
    }
    
    // Auto-fill expected domain from target for HTTP/HTTPS/Kafka/TCP
    if (targetField && checkDomainCheckbox && expectedDomainField) {
        targetField.addEventListener('blur', function() {
            const type = monitorType.value;
            const supportsAutoDomain = ['http', 'https', 'kafka', 'tcp', 'ping'].includes(type);
            if (supportsAutoDomain && checkDomainCheckbox.checked && !expectedDomainField.value) {
                const domain = extractDomainFromUrl(this.value);
                if (domain) {
                    expectedDomainField.value = domain;
                }
            }
        });
        
        // Enable/disable expected domain field based on check domain checkbox
        checkDomainCheckbox.addEventListener('change', function() {
            expectedDomainField.disabled = !this.checked;
            if (this.checked && !expectedDomainField.value && targetField.value) {
                const domain = extractDomainFromUrl(targetField.value);
                if (domain) {
                    expectedDomainField.value = domain;
                }
            }
        });
        
        // Initialize expected domain field state
        expectedDomainField.disabled = !checkDomainCheckbox.checked;
    }
    
    // Attach event listeners for Kafka fields
    if (kafkaSecurityProtocol) {
        kafkaSecurityProtocol.addEventListener('change', updateKafkaFields);
        updateKafkaFields(); // Initial state
    }
    if (kafkaSaslMechanism) {
        kafkaSaslMechanism.addEventListener('change', updateKafkaFields);
    }
    if (kafkaWriteMessage) {
        kafkaWriteMessage.addEventListener('change', updateKafkaFields);
    }
    
    // Attach HTTP method event listener
    if (httpMethod) {
        httpMethod.addEventListener('change', updateHttpBodyVisibility);
        updateHttpBodyVisibility(); // Initial state
    }
});

// Delete monitor confirmation - attach to button via event listener (only on edit page)
document.addEventListener('DOMContentLoaded', function() {
    const deleteBtn = document.getElementById('deleteMonitorBtn');
    const deleteForm = document.getElementById('deleteForm');
    if (deleteBtn && deleteForm) {
        deleteBtn.addEventListener('click', function() {
            if (confirm('Are you sure you want to delete this monitor?')) {
                deleteForm.submit();
            }
        });
    }
});